[视频](https://www.bilibili.com/video/BV1Ft421t7PS)开头介绍了本次活动的主办方中国科学院软件所下属的 PLCT 实验室，演讲者邱吉博士、组织者吴伟大使和陈逸轩，《RISC-V Optimization Guide》的发布组织 RISE 基金会

RISE基金会发布了《RISC-V Optimization Guide》，旨在为全球工程师和学习者提供更加便捷的开发与学习体验。为了更好地理解该指南，读者可参考RISC-V官方网站，同时建议阅读计算机体系结构基础知识和编译器基础知识。在此，我们推荐经典书籍《编译原理》（俗称“龙书”）作为学习的参考书目。此外，您还可以通过b站up主lazyparser分享的技术视频，以及邱吉老师在Hellollvm社区分享的[关于体系架构与编译器后端的内容](https://www.bilibili.com/video/BV1a84y1S7J7)，以补充相关知识。

文档发布时间是2024.2.26: [链接](https://riscv-optimization-guide-riseproject-c94355ae3e6872252baa952524.gitlab.io/riscv-optimization-guide.html)

《RISC-V Optimization Guide》共计五个章节，14页内容。鉴于**RISC-V是一个模块化设计的指令集**，包含基本指令集、标准扩展及定制化扩展，因此其提供的ISA接口呈现多样性。本指南第二章详细介绍了新版Linux上推出的探测方法，这一方法有效解决了因指令集多样性带来的问题。第三章和第四章则分别聚焦于标量定点和浮点操作的优化策略。最后一章详细探讨了向量操作的优化技巧。通过对本指南的学习，工程师和学习者可以更全面地了解RISC-V的相关优化技巧，从而在实际开发和应用中更加得心应手。

第一章主要介绍了本指南的目标读者群体。这些读者包括但不限于从事编译器与指令相关优化的工程师、参与Linux kernel RISC-V部分开发的工程师、RISC-V汇编指令开发者，以及从事高性能库开发的工程师和教师群体。在这一章节中，还特别强调了以下概念：在进行cpu优化或底层优化时，应将具体实现无关和具体实现相关的因素分开考虑。具体实现相关通常指的是由特定厂商生产的某一款cpu或发布的cpu IP，而具体实现无关则指的是这份指南仅针对RISC-V ISA spec，不涉及特定厂商的具体实现细节。因此，这份指南的宝贵之处在于它对所有标准RISC-V的实现都普遍适用。只要一个处理器声称自己遵循RISC-V指令集，那么这份指南就能为其提供有用的指导。然而，对于非标准的RISC-V指令集，这份指南并不适用。最后，第一章还强调了如果厂商希望自家的处理器能被用户更好地使用，就应该推出与具体实现相关的指南，和该指南搭配使用。

第二章重点介绍了Linux 6.4版本中引入的新系统调用——riscv_hwprobe。这个系统调用允许用户获取cpu的详细信息，包括支持的扩展指令集以及是否支持快速的非对齐内存访问。对于希望深入了解这一特性的读者，可以参考邱吉博士之前的视频资料。

过去，各种指令集架构都使用HWCAP来获取处理器信息，但riscv_hwprobe的优势在于它为未来的扩展指令集预留了充足的bit field，甚至支持多字符扩展的探测（如Zbb/Zba/Zbs）。文档的第二页提供了一个示例程序，展示了如何使用 riscv_hwprobe 系统调用。

这一新特性为编译器开发者带来了机会，可以借此机会实现编译器的多版本支持。所谓编译器的多版本支持，是指在编译过程中，虽然只生成一份可执行程序，但该程序内部包含了多个不同的执行单元执行路径。这样，在运行时，可以根据硬件平台的特征动态地选择执行逻辑流程，从而分发到不同的二进制单元中。例如，如果发现RISC-V处理器支持向量操作，就会执行向量版本的代码，否则就执行标量版本。

GCC和LLVM等编译器框架中，这种特性被称为target_clone，但目前RISC-V还没有原生支持。对于关注这一领域进展的读者，可以访问以下链接以获取最新信息：

[LLVM进展](https://reviews.llvm.org/D151730)

[Mask Ray的博客](https://maskray.me/blog/2023-02-05-function-multi-versioning)

第三章是讲标量定点操作的优化。标量操作就是说每次只操作一个元素，一个寄存器里面就只包含一个元素，要么是8位、32位或者64位，要么是有符号或者无符号。

3.1讲的是常量的具体化（materializing），就是把立即数常量放到寄存器的方法。 RISC-V 用 `addi`、`lui`、`auipc`来加载立即数常量，对于一个有符号的12 bit 立即数常量可以直接使用 `addi` 这条指令。对于一个有符号的32 bit 立即数，则需要用一对指令来进行拆分。值得一提的是，在拆分常量的时候，12bit的立即数域在指令集定义时被定义成了有符号数，所以当低12位的最高位为1时，需要特殊处理。文档中的例子讲得不是很透彻，原理和推导过程推荐史宁宁老师的[专栏](https://zhuanlan.zhihu.com/p/374235855) 。编译器的汇编器提供了好用的修饰符 `%hi `
 和 `%lo` 来处理此类立即数常量的拆分问题，使用的时候可以直接让汇编器帮你拆好。或者写汇编的时候直接使用伪指令 `li` 。所以其实做汇编器的程序员开发好了相关拆分功能，其他程序员不需要考虑这个问题。

3.2讲的是有效利用 `x0` 寄存器。`x0` 寄存器是全0常量寄存器,不可修改。如果用别的指令存0, 会有额外的开销。另外，要有效利用指令的立即数域，而不是单独加载立即数。例如标量指令具有 12 bit 的立即数域，向量指令具有 5 bit 的立即数域。比如，应使⽤ `ld t0, 8(a0)` ⽽不是 `addi a1,a0,8; ld t0, (a1)`，这样的话就可以省掉 `addi` 到新的地址这个指令。扩展一下，推荐 RISC-V 立即数优化的相关资料， Craig Topper 是 LLVM RISC-V 的 maintainer, 他写过：[文档](https://llvm.org/devmtg/2022-11/slides/TechTalk21-RISC-VSignExtensionOptimizations.pdf) ，相关[视频](https://youtu.be/TmWs3QsSuUg?feature=shared) 。还有廖春玉老师的中文版：[改进 RISC-V 的代码生成](https://www.bilibili.com/video/BV1pN411H7Y3) 。

3.3 对 64 bit 的立即数常量使用常量池。由于 RISC-V 的 `addi` 指令只有 12 bit 的立即数域，所以加载 64 bit 的立即数最多会用到1条 ` lui` 和4条 `addiw` 指令 （20+12*4=68 bit）。经典序列(加载⽴即数 0x123456789abcde1到a0) 一共有8条指令，在RV64G下 32 byte, RV64GC 下 26 byte 。如果用常量池的话，先把常量放进 .rodata 段里面去，在加载这个数的时候先用 auipc 把 large_constant 加载进 a0 寄存器高二十位，然后再用低12位的立即数偏移从 `%pcrel_lo` 加载进来。这样的话，消耗总共 32 byte，加载指令 16 byte，常量池 16 byte，如果该常量在程序中使用多次的话，存储的开销会被摊平，收益更大。编译器里面应该已经完成了这个功能，高性能库的开发者在手写汇编的时候可能需要看一下使用常量池的做法。

3.4 和 3.5 使用经典的 `move` 指令和使用条件 `move` 来代替分支。我们知道，处理器在进行分支预测的时候代价很高，在遇到分支的时候要去预测跳转或者不跳转，以及目标分支的预测。每次预测错误了之后整个流水线是要被清空重来的，代价会相对非常高，把分支指令替换成条件move 是编译器的一种常见优化，实际上是把对控制流的依赖变成了对数据的依赖。RISC-V 有一个 Zicond 扩展，主要引入了两个指令，一个是 `czero.eqz rd, rs1, rs2`, 另一个是 `czero.nez rd, rs1, rs2`。这两个指令的语意是，在 rs2 中存一个 condition ，当 condition = 0 或者 condition != 0 时，rs1 赋值给 rd ，否则 rd 置零。文档中有一个例子，使用 czero.nez 修改之后，虽然和之前指令数一样多，还是四条，但是没有分支指令了，执行的时候不需要分支预测，时序就会好一些。接下来还有一些优化，比如说刚才的 condition1 如果能在 12 位有符号整型范围之内编码的话，那么 `addi` 指令就可以代替前面 `li constant1` 。当然如果没有 Zicond 扩展，也可以使用 seqz 和逻辑组合来达成条件move。这就是一个比较绕的例子了。通过 seqz 来获得一个逻辑的真假值，再通过 `addi t0, t0, -1` 来使得 t0 变成一个全0 或者全 1 的mask，通过xor、and、xor操作来选取t2或者t3的值。这个逻辑大家有兴趣的可以看一下，一般手写程序不会用到这么复杂的逻辑，通常可能是在编译器里面代码生成比较后端，要优化的时候，用到这些序列去做比较，比如说窥孔优化或者简单的替换。包含 M 扩展的RISC-V 指令集可以使用 mul 指令进行更进一步优化。最简单的情况，如果 condition1 和 condition2 分别是0和1的时候，只需要一条指令就可以完成。实现的逻辑就是，如果 a0 输入的值等于0的话，result = true, 否则 result = false 。C语言需要两条语句完成，汇编一条就能完成，这种翻译对编译器来说非常高效。

3.6 讲的是代码段的 padding 。padding 就是在软件开发中，为了对齐数据或满足特定要求，可以在代码中插入额外的无关紧要的指令。代码段为什么需要 padding 呢？因为我们为函数生成代码的时候，希望分支跳转的目标或者说函数的起始地址，能够 padding 在 cache 行的开头的地址上，这样对整个跳转或者取址都是有利的。所以需要在编译一个编译单元，就是一整个函数结束的时候，在尾巴上 padding 一下，让它能够占满一个 cache 行，或者说是安排一个函数开头地址的时候，也把地址 padding 到一个 cache line 开头的地址上去，这样在函数调用的时候能从开头的地方取满一行，正好执行这个函数。这种情况存在两种 padding, 一种 padding 是当编译完一个函数之后，函数内部的 padding, 可能有一个跳表 (switch case)这样的一个点。当然希望在函数内部跳转的时候，热点比较大的跳转目标是被 alignment 过的。函数内部的 padding 推荐使用 `nop` ( `addi x0, x0, 0` ) 或者 `c.nop` ( `c.addi x0, 0` )，函数之间对齐 padding 推荐使用0。对于 RISC-V 来说，如果取址取到0的话是一条非法指令，文档没有具体解释为什么，邱老师推测，因为在程序运行过程中，在某个函数内部的执行频率高，当执行到有分支的情况后在函数内部跳转，一些比较小的函数为了减少函数调用的开销，编译器在 -O3 的情况下可能会 inline 化。热点函数都是倾向于在函数内部。如果一个 cpu 在乱序执行的情况下，流水线遇见非法指令，可能有一些跟 cpu 具体实现相关的策略会导致不执行后续指令了，或者说遇到非法指令后，要保留额外的信息，把这条指令传下去的话，可能会影响到流水线的效率。所以在函数内部执行的时候，padding 使用 `nop` 或者 `c.nop`，不会影响后续指令的执行。在函数之间对对齐的时候，控制流如果取到了 padding 进去的非法指令的话，极有可能是程序的控制流出错了。用 0 去 padding 有利于抓住程序出错的而状态，帮助 debug 。如果大家有更好的见解，可以一起讨论。

3.7节是将字符数组对其到更大的对齐单位，对访问的对齐或非对齐对访存效率影响有背景知识的小伙伴看到这一点会很容易理解。如果 RISC-V 处理器不支持快速非对齐访问的话，最好使用 lw 或 sw 指令从4字节边界访问， ld/sd从8字节边界访问，效率会高很多。退一步讲，即便 cpu 是支持非对齐访问的，编译器或者写程序的时候把数组地址对其到合适的边界上性能也会更好。访存对齐之后不论是内存的控制器还是访存部件，或者处理器里其他加速访问的功能都能更好地去实现。

3.8节讲的是使用移位指令去除前导位和末尾位，推荐直接使用 `slli` 和 `srli`，而不是用指令更多的`lui`、`addi`、`and`，把高20位做成1个 mask，然后进行 `and` 操作。最简单的原因就是指令的数量不一样，我们应该用更少的指令去实现同样的功能。

以上9点就是第三章标量定点优化操作里面的注意事项。

第四章是标量浮点操作的优化。标量浮点操作的优化实际上有一些原则是跟定点操作相同的。比如说尽量使用短的序列去实现相同的功能、0的折叠、以及访存的对齐，这些都是相通的。标量浮点操作比较特殊的就是 RISC-V 提供了一种非常灵活的浮点指令计算舍入模式的设置方式，有两种模式，一种是静态模式，一种是动态模式。静态模式就是每一条浮点计算指令有一个编码域设置文档图示列表里的舍入模式。动态的模式就是 RISC-V 提供了一个 CSR 系统浮点状态寄存器，有 frm 的位域，可以通过 CSR write 指令去设置 frm 域，进而使得具有 Dynamic mode 的浮点计算指令按照 frm 域里面不同的舍入模式进行计算。如何尽可能地使用静态模式呢？比如说要进行单精度浮点的加操作，可以通过使用 rtz (Round toward Zero) 这种舍入模式来进行静态舍入，如 `fadd.s f10, f10, f11, rtz` 。而不是先使用 `csrrwi t0, frm, 1` ，来设置 CSR，因为 1 代表 rtz 。因为首先设置  CSR 使指令数变多了，其次  CSR 在读取的时候，时序比普通指令更长，设置 CSR 的时候需要指令流水线的同步。用 CSR 设置完处理器的舍入模式之后，被提前计算的指令要被清除掉，因为 frm 改变了。指令序列要精确的话，设置 frm 指令之后所有指令的计算要按照新的模式来舍入，这样会导致流水线中断，产生 flush 。这就是所有关于标量浮点操作的优化。

第五章是向量操作的优化。可能向量操作的优化对于普通程序员有点陌生，因为手头上实际能操作的具有 V 扩展的硬件很少，邱老师其实也没有真正编程或者性能优化过。有些部分是在理解 spec 基础上的推断，不是有确凿的证据一定是这样，如果有异议或者其他见解可以提出来一起讨论。

5.1节保留 v0 寄存器作为 mask 寄存器来使用。这一点在 V 扩展 spec 里明确的讲了，所有的向量寄存器只有 v0 可以当 mask 寄存器，所以如果你要用 mask 的方式来计算的话，v0 里面就不要再放数据了，否则会造成额外的开销。

5.2节权衡 VLA 和 VLS 编程模式。 RISC-V V extension 有不同的配置，vlen、sew和lmul之类的可以不同，最简单的就是向量寄存器的宽度可以不同，从128 bit 到2048 bit 都可以，这样就会导致编程时候如何把数组映射到寄存器里的模式也不一样。Vector-length agnostic (VLA) 编程模式需要代码在运⾏时⾃⾏判断硬件所提供的向量⻓度，然后适配，移植性好，但代码的逻辑复杂，不容易极致调优。Vector-length specific(VLS)精确⾯向特定 vlen 编程，更容易逼近性能峰值。可能目前大部分情况下都是 VLS 的模式， VLA 还是比较少，同时也可以通过之前提到的 multi-version 来实现灵活可变和性能之间的折中，就是一份代码编译成不同 vlen 的形式，但是分发的时候 code binary side就增加了。这一部分也是做 SIMD、自动向量化、还有底层库开发者需要考虑的，在这两种模式之间 trade-off 。

5.3节设置 vl (Vector Length register)和 vtype (Vector Type register)。如果写过 RISC-V V extension 指令，肯定避免不了用 vsetvli、vsetivli 去设置 vl 和 vtype, 甚至是对 ta (tail agnostic)、ma ( mask agnostic) 这些模式进行设置。指南里面说比较推荐立即数形式的设置，而不推荐用寄存器形式去设置指令。因为使用寄存器作为原操作数去设置 vl 和 vtype 的话，必然涉及到要用一些额外的拼接指令实现。

5.4节使用高效的掩码操作。掩码操作在文档里其实叫 predicting ，预测操作。在邱老师的理解里，掩码含义是说哪些元素要操作，哪些元素不操作，跟 Predicating 是一样的。文档的高效掩码操作里有几个小的点。第一个点是尽量避免使用勿扰模式(undisturbed)，什么叫勿扰模式，就是处理一个向量的时候通过mask去让有的元素操作，有的元素不操作，通过 tail 设置末尾的几个元素不要操作。如果在处理 mask 和 tail 类型的元素时，使用了勿扰模式的话，就会导致原寄存器要先被读取，计算完了之后只把需要的值拼接回去，就造成了原寄存器多一次读，然后拼接的操作。邱老师理解的拼接操作开销不是很大，但是原寄存器的读，尤其是在向量寄存器堆里面读的话，会占用端口，所以开销比较大，而且它执行时间长了，也会影响其他的指令来读写寄存器，所以推荐非必要不使用勿扰模式。直接让 mask 掉的值或者 tail 的值运算完了是 undedfined 状态或者直接置0。文档说也可以先选择 copy 目标寄存器做一个备份，最后再把这两个值通过其他指令拼接起来。邱老师对先copy, 再拼接持保留态度，似乎收益不大。具体的在具体程序里调试的时候写成不同模式测试一下才好。5.4.2避免使用 mask，硬件开发工程师刘玖阳分享使不使用 mask 是跟微架构相关的，跟指南的想要具体实现无关说法相违背，有些超纲。如果需要向量前导部分的元素，使用 vl 设置向量长度就可以，比如说写一个 case, 如果只需要前面 0、1、2 的元素，把 vl 设置成3就可以了，而不是用 mask 将后面的 mask 掉。邱老师理解的 mask 拼来拼去的开销是大于 vsetvl 、vsetvli、vsetivli 指令的。5.4.3将 vl 舍入到数据通路宽度（向量寄存器宽）上。在这里提到数据通路宽度，可能会认为它指的是内存控制器的访问宽度或其他的宽度。然而，这里所指的是向量寄存器的宽度，即 VLEN 的宽度。这里讨论的是那些没有副作用的向量指令，即不包括 load 和 store 等指令。 如果程序语义要处理不同长度的向量，例如处理长度为2、4 和 8 的数组，可以通过设定 vl 和 vtype 来调整数据通路宽度 vlen。举例来说，若我们的 vlen 是 128 位，可将 vlen 设定为 128 位，然后将 vtype 设定为 32 或 64。这样的话一条 vsetvl 指令就可以兼容所有向量长度。 在计算仅有两个元素的数组时，未定义的两个数组也计算了，浪费了一些计算带宽。然而，生成这两个元素实际上对处理器来说并没有额外开销，因为在时序上是相同的。 vsetvl 指令的使用减少了，因为对于这三种不同的向量长度，只需使用一种 setvl 指令就能完成 vl 和 vtype 的设置，就可以开始计算了。即便浪费一些计算也没有关系，因为指南觉得 setvl 指令的开销更大。

5.5精心选择 emul 和 lmul 值。这里简要介绍一下什么是 emul 和 lmul 值。在每个向量操作数中，存在一个名为 effective element width，通常情况下，effective element width 等于 single element width，这是向量扩展中的两个术语。此外，每个向量操作数还有 elmul ，通常情况下 emul 等于 lmul。那么 lmul 又代表什么呢？lmul 是 length multiplier 的缩写，它表示可以将寄存器分组，当 lmul 等于1 时，就是单个寄存器，如果 lmul 等于二的情况下，可能就是把从0~1的两个寄存器给它连起来了。  当源操作数和向量目标具有相同个数，但元素位宽不同时，eew 和 emul 与 sew 和 lmul 就会有所不同。例如，从 16 位扩展到 32 位的符号扩展指令或压缩指令，会导致 emul 和 lmul 完全不同，可能是成倍增加或缩减。总结一下这部分的背景：通过设置 lmul 值越大，每条指令需要读写的寄存器数量就会增加，因为设置的值越大，导致需要更多的寄存器组。这将增加对寄存器端口的压力，可能影响执行速度。lmul的值越小，意味着处理同样长度的向量就需要更多的向量指令，cpu执行更多的指令，取指执行提交，流水线的执行的指令数就会更多，又有可能消耗更长的时间。所以 lmul .的值的选取，到底是大还是小，跟 cpu 取指的位宽，寄存器读写的端口数都是有关系的。 要获得最佳性能时，需要精细调整 emul 和 lmul 值。 emul 值取决于不同的指令，它可能随指令的不同而有所变化。当选择 lmul 值时，也需要考虑指令的特性，确定指令会写入多少个寄存器，随之调整这个值。 lmul 值的调整会影响 emul 值，这可能显得有些复杂，但是如果对这部分进行编程实践，一定会理解。因此，在调整这些值以优化性能时，需要非常细心地调整 lmul 和 emul，以便在具体硬件上获得最佳值。

5.6使用开销小的指令序列。使⽤.vx 和 .vf指令，来减⼩向量寄存器读写开销。在 RISC-V V 扩展中，寄存器端口读写指的是向量指令中的 vv、vx 和 vf 类型指令。vv 表示两个操作数都来自向量寄存器，vx 表示一个来自定点寄存器，一个来自向量寄存器，而 vf 表示一个来自浮点寄存器，另一个来自向量寄存器。通过使用这些指令，可以尽可能减少向量寄存器的读写开销，但相应地增加了定点和浮点寄存器的读写开销，将开销分摊到其他寄存器组上。举例来说，如果要对一个数组中的所有元素加上 1.0，传统做法是先创建一个元素都为 1.0 的向量，然后与原始向量逐个元素相加。但实际上，推荐的做法不是将 t0 转换为单精度浮点存储在 a0 中，而是直接使用 vfadd 指令，将浮点寄存器中的 a0 的元素直接加到 v8 寄存器的每个元素上，得到 v10，并将结果存回。这是推荐的操作序列。例2: 加载3到向量寄存器⾥并⼴播到所有lanes，如果要将一个值加载到向量寄存器中并广播到所有元素，可以简单地使用 vmv.v.i 指令，而不需要考虑是否需要将该值移位或者如何广播。这条指令是产生最短、开销最小的指令序列的方法。

5.7 向量指令的舍⼊模式控制。讨论了向量指令的舍入模式控制。大部分向量指令在执行浮点计算时通常没有静态模式的舍入控制，因为向量指令的编码域中已经包含了很多信息，再额外添加静态模式的控制会难以实现。由于立即数仅有 5 位编码 而不是 12 位，因此它已经被编码了。因此，要控制浮点向量指令执行时的舍入模式，大多数情况下需要通过 CSR 中的 frm 域来进行调整。由于 CSR 的读写操作开销较大，可能会导致流水线中断。所以需要更加精⼼的安排指令，尽量减少FPCSR.FRM的读写，从

⽽减⼩流⽔线停顿。这部分相对于单纯的标量浮点来说，调试花费的精力就更多了。

5.8 向量访存指令的使⽤优先顺序。在向量访存指令的使用优先顺序中，考虑到存在七种不同的寻址模式，总体原则是按照指令列表中的顺序选择，通常随着地址生成复杂度增加，访存开销可能会增大。特别是在存在地址跳跃的情况下，处理器可能无法有效地进行预取操作，导致性能下降。因此，针对不同程序特征，选取适合的指令模式是关键 。Index segment 指令旨在解决某些特殊的访存方式，因此如果程序中存在这种访存序列，使用相应的指令模式是提高程序效率的关键，而不仅仅是遵循固定的优先顺序或者一定要用整个寄存器。具体实现方式和特定程序行为和处理器架构强相关，不做具体解释了。

5.9 尽量使⽤整个寄存器内存读写。作者强调尽量使用整个读写，因为这种指令序列简单、地址计算简单，无需额外的 vsetvl 指令。举例来说，从数组 a1 中拷贝一段连续内存到 a0，可以利用完整的寄存器读写，直接读取。通过设置 t0 的长度，通过 csrr (csr read) 把 vlen bit 按位将其读入 t0 寄存器，然后 t0 作为每次加和减的步长。实际上，如果没有完整地使用整个寄存器，只能以一种较为繁琐的形式来实现。因此，尽管这一点可能表达得比较含蓄，但强调了使用整个寄存器的操作会更为简单和高效。

总结今天的解读：这份指南提供了针对 RISC-V 标准指令集最基础和普适的优化操作，不受厂商和 cpu 型号的限制，适用于所有 RISC-V 机器，可带来性能优化和提升。虽然也存在一些例外和特例，但对于编译器、库开发者以及做软硬件协同优化、性能调优和微架构优化的人员，这些优化思路是非常值得参考的。期待未来更多厂商能提供更详细的优化指南。

